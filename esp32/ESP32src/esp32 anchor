#include "dw3000.h"
#include "SPI.h"

extern SPISettings _fastSPI;

#define PIN_RST 27
#define PIN_IRQ 34
#define PIN_SS 4

#define TX_ANT_DLY 16385
#define RX_ANT_DLY 16385
#define ALL_MSG_COMMON_LEN 10
#define ALL_MSG_SN_IDX 2
#define RESP_MSG_POLL_RX_TS_IDX 10
#define RESP_MSG_RESP_TX_TS_IDX 14
#define RESP_MSG_TS_LEN 4
#define POLL_RX_TO_RESP_TX_DLY_UUS 450

/* dw3000 에서 모듈을 위해 제공하는 구조체 */
static dwt_config_t config = {
    5,                /* 채널 번호 */
    DWT_PLEN_128,     /* 프리엠블 길이, 송신에 사용됨 */
    DWT_PAC8,         /* 프리앰블 획득 청크 크기, 수신에 사용됨*/
    9,                /* 송신 프리앰블 코드 */
    9,                /* 수신 프리앰블 코드 */
    1,                
    DWT_BR_6M8,       /* 데이터 전송률 */
    DWT_PHRMODE_STD,  /* PHY 헤더 모드 */
    DWT_PHRRATE_STD,  /* PHY 헤더 전송률 */
    (129 + 8 - 8),    /* SFD 타임아웃 */
    DWT_STS_MODE_OFF, /* STS 비활성화 */
    DWT_STS_LEN_64,  
    DWT_PDOA_M0       /* PDOA 모드 비활성화 */
};

/* 수신 메시지를 수신하기 위한 배열*/
static uint8_t rx_poll_msg[] = {0x41, 0x88, 0, 0xCA, 0xDE, 'W', 'A', 'V', 'E', 0xE0, 0, 0};   

/* 응답 메시지를 송신하기 위한 배열 */
static uint8_t tx_resp_msg[] = {0x41, 0x88, 0, 0xCA, 0xDE, 'V', 'E', 'W', 'A', 0xE1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; 

/* 프레임 시퀀스 번호 */
static uint8_t frame_seq_nb = 0;   

/* 수신된 데이터를 저장하기 위한 버퍼. */
static uint8_t rx_buffer[20];

/* DW3000의 상태 레지스터 값을 저장하기 위한 변수. */
static uint32_t status_reg = 0;

/* 수신 메시지의 수신 타임스탬프. */
static uint64_t poll_rx_ts;     

/* 응답 메시지의 송신 타임스탬프. */
static uint64_t resp_tx_ts;

extern dwt_txconfig_t txconfig_options;

void setup()
{
  UART_init();

  _fastSPI = SPISettings(16000000L, MSBFIRST, SPI_MODE0);

  spiBegin(PIN_IRQ, PIN_RST);
  spiSelect(PIN_SS);
  
  delay(2); 

  while (!dwt_checkidlerc())  // DW IC가 IDLE_RC 상태인지 확인
  {
    UART_puts("IDLE FAILED\r\n");
    while (1)
      ;
  }

  if (dwt_initialise(DWT_DW_INIT) == DWT_ERROR) // DW3000 초기화
  {
    UART_puts("INIT FAILED\r\n");
    while (1)
      ;
  }

  // 디버그를 위한 LED 활성화
  dwt_setleds(DWT_LEDS_ENABLE | DWT_LEDS_INIT_BLINK);

  // DW IC 구성
  if (dwt_configure(&config)) 
  {
    UART_puts("CONFIG FAILED\r\n");
    while (1)
      ;
  }

  /* TX 스펙트럼 매개변수 구성 */
  dwt_configuretxrf(&txconfig_options);

  /* 기본 안테나 지연 값 적용 */
  dwt_setrxantennadelay(RX_ANT_DLY);
  dwt_settxantennadelay(TX_ANT_DLY);

  /*  TX/RX 상태 출력을 GPIO에 활성화하여 디버그 도움 */
  dwt_setlnapamode(DWT_LNA_ENABLE | DWT_PA_ENABLE);

  /* 시리얼 출력으로 범위 측정 시작 및 설정 완료 알림 */
  Serial.println("Range TX");
  Serial.println("Setup over........");
}

void loop()
{
  /* 수신 활성화 */
  dwt_rxenable(DWT_START_RX_IMMEDIATE);

  /* 프레임 수신 또는 오류/ 타임아웃을 위한 폴링 */
  while (!((status_reg = dwt_read32bitreg(SYS_STATUS_ID)) & (SYS_STATUS_RXFCG_BIT_MASK | SYS_STATUS_ALL_RX_ERR)))
  {
  };

  // RX 프레임 이벤트가 발생했는지 확인
  if (status_reg & SYS_STATUS_RXFCG_BIT_MASK)
  {
    uint32_t frame_len;

    // DW IC 상태 레지스터에서 RX 프레임 이벤트 클리어
    dwt_write32bitreg(SYS_STATUS_ID, SYS_STATUS_RXFCG_BIT_MASK);

    // 수신된 프레임을 로컬 버퍼로 읽기
    frame_len = dwt_read32bitreg(RX_FINFO_ID) & RXFLEN_MASK;
    if (frame_len <= sizeof(rx_buffer))
    {
      dwt_readrxdata(rx_buffer, frame_len, 0);

      // 수신된 프레임이 "SS TWR initiator" 예제에서 보낸 폴인지 확인
      rx_buffer[ALL_MSG_SN_IDX] = 0;
      if (memcmp(rx_buffer, rx_poll_msg, ALL_MSG_COMMON_LEN) == 0)
      {
        uint32_t resp_tx_time;
        int ret;

         // 수신 타임스탬프 검색
        poll_rx_ts = get_rx_timestamp_u64();

        // 응답 메시지 송신 시간 계산
        resp_tx_time = (poll_rx_ts + (POLL_RX_TO_RESP_TX_DLY_UUS * UUS_TO_DWT_TIME)) >> 8;
        dwt_setdelayedtrxtime(resp_tx_time);

        // 응답 TX 타임스탬프는 프로그램된 송신 시간 + 안테나 지연
        resp_tx_ts = (((uint64_t)(resp_tx_time & 0xFFFFFFFEUL)) << 8) + TX_ANT_DLY;

        // 최종 메시지에 모든 타임스탬프 작성
        resp_msg_set_ts(&tx_resp_msg[RESP_MSG_POLL_RX_TS_IDX], poll_rx_ts);
        resp_msg_set_ts(&tx_resp_msg[RESP_MSG_RESP_TX_TS_IDX], resp_tx_ts);

        // 응답 메시지 작성 및 송신
        tx_resp_msg[ALL_MSG_SN_IDX] = frame_seq_nb;
        dwt_writetxdata(sizeof(tx_resp_msg), tx_resp_msg, 0); 
        dwt_writetxfctrl(sizeof(tx_resp_msg), 0, 1);          
        ret = dwt_starttx(DWT_START_TX_DELAYED);

        // dwt_starttx()가 오류를 반환하면 이 범위 교환을 포기하고 다음으로 진행
        if (ret == DWT_SUCCESS)
        {
          // TX 프레임 전송 이벤트 설정될 때까지 DW IC 폴링
          while (!(dwt_read32bitreg(SYS_STATUS_ID) & SYS_STATUS_TXFRS_BIT_MASK))
          {
          };

          // TXFRS 이벤트 클리어
          dwt_write32bitreg(SYS_STATUS_ID, SYS_STATUS_TXFRS_BIT_MASK);

           // 폴 메시지 송신 후 프레임 시퀀스 번호 증가
          frame_seq_nb++;
        }
      }
    }
  }
  else
  {
    // DW IC 상태 레지스터에서 RX 오류 이벤트 클리어
    dwt_write32bitreg(SYS_STATUS_ID, SYS_STATUS_ALL_RX_ERR);
  }
}
